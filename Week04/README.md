### 1.作业

按照自己的构想，写一个项目满足基本的目录结构和工程，代码需要包含对数据层、业务层、API 注册，以及 main 函数对于服务的注册和启动，信号处理，使用 Wire 构建依赖。可以使用自己熟悉的框架。

### 2.项目目录

```
|____cmd                
| |____server              # 编译入口
| | |____wire_gen.go
| | |____wire.go
| | |____main.go
|____test                  # 测试服务API
| |____user.go
|____bin
| |____server              # 编译好的二进制文件
|____Makefile              # 项目编译、运行、测试快捷命令
|____internal
| |____biz                 # 业务组装层
| | |____user.go
| |____service             # API实现层
| | |____user.go
| |____data                # 数据层
| | |____user.go
| |____pkg                 # 公共库
| | |____grpc              # gRPE Server封装
| | | |____service.go
|____README.md
|____api                   # rpc文件
| |____user
| | |____v1
| | | |____user_grpc.pb.go
| | | |____user.pb.go
| | | |____user.proto
```
### proto 定义

```go
syntax = "proto3";

package user.v1;

option go_package = "Week04/api/user/v1;v1";


service User {
  rpc RegisterUser (RegisterUserRequest) returns (RegisterUserReply) {}
}

message RegisterUserRequest {
  string name = 1;
  int32 age = 2;
}

message RegisterUserReply {
  int32 id = 1;
}
```

### 数据层 `data`

```go
// data/user.go

package data

import (
	"Week04/internal/biz"
	"log"
)

var _ biz.UserRepo = new(userRepo)

const (
	userID = 100
)

func NewUserRepo() biz.UserRepo {
	return &userRepo{}
}

type userRepo struct{}

func (r *userRepo) Save(u *biz.User) int32 {
	log.Printf("save user, name: %s, age: %d, id: %d", u.Name, u.Age, userID)
	return userID
}
```

### 业务组装层 `biz`

```go
// biz/user.go

package biz

type User struct {
	ID   int32
	Name string
	Age  int32
}

type UserRepo interface {
	Save(*User) int32
}

func NewUserUsecase(repo UserRepo) *UserUsecase {
	return &UserUsecase{repo: repo}
}

type UserUsecase struct {
	repo UserRepo
}

func (s *UserUsecase) SaveUser(u *User) {
	id := s.repo.Save(u)
	u.ID = id
}
```

### API实现层 `service`

```go
// service/user.go

package service

import (
	v1 "Week04/api/user/v1"
	"Week04/internal/biz"
	"context"
)

type UserService struct {
	u *biz.UserUsecase
	v1.UnimplementedUserServer
}

func NewUserService(u *biz.UserUsecase) v1.UserServer {
	return &UserService{u: u}
}

func (s *UserService) RegisterUser(ctx context.Context, r *v1.RegisterUserRequest) (*v1.RegisterUserReply, error) {
	// dto -> do
	u := &biz.User{Name: r.Name, Age: r.Age}

	// call biz
	s.u.SaveUser(u)

	// return reply
	return &v1.RegisterUserReply{Id: u.ID}, nil
}
```

### RPC Server封装

```go
// pkg/grpc/server.go

package grpc

import (
	"context"
	"log"
	"net"

	"google.golang.org/grpc"
)

type Server struct {
	*grpc.Server

	address string
}

func NewServer(address string) *Server {
	srv := grpc.NewServer()
	return &Server{Server: srv, address: address}
}

func (s *Server) Start(ctx context.Context) error {
	l, err := net.Listen("tcp", s.address)
	if err != nil {
		return err
	}

	log.Printf("grpc server start: %s", s.address)

	go func() {
		<-ctx.Done()
		s.GracefulStop()
		log.Printf("grpc server gracefull stop")
	}()

	return s.Serve(l)
}
```

### 启动入口

#### `cmd/server/wire.go`

```go
//+build wireinject 忽略编译

package main

import (
	"Week04/internal/biz"
	"Week04/internal/data"

	"github.com/google/wire"
)

func InitUserUsecase() *biz.UserUsecase {
	wire.Build(biz.NewUserUsecase, data.NewUserRepo)
	return &biz.UserUsecase{}
}
```

#### `cmd/server/wire_gen.go`

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"Week04/internal/biz"
	"Week04/internal/data"
)

// Injectors from wire.go:

func InitUserUsecase() *biz.UserUsecase {
	userRepo := data.NewUserRepo()
	userUsecase := biz.NewUserUsecase(userRepo)
	return userUsecase
}
```

#### `cmd/server/main.go`

```go
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"

	pb "Week04/api/user/v1"
	"Week04/internal/pkg/grpc"
	"Week04/internal/service"

	"golang.org/x/sync/errgroup"
)

const (
	address = ":9800"
)

func main() {
	// init service api
	us := InitUserUsecase()
	service := service.NewUserService(us)

	// register grpc service
	s := grpc.NewServer(address)
	pb.RegisterUserServer(s, service)

	// context
	ctx, cancel := context.WithCancel(context.Background())
	g, ctx := errgroup.WithContext(ctx)

	// start grpc server
	g.Go(func() error {
		return s.Start(ctx)
	})

	// catch signals
	g.Go(func() error {
		sigs := make(chan os.Signal, 1)
		signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
		select {
		case sig := <-sigs:
			log.Printf("signal caught: %s, ready to quit...", sig.String())
			cancel()
		case <-ctx.Done():
			return ctx.Err()
		}
		return nil
	})

	// wait stop
	if err := g.Wait(); err != nil {
		log.Printf("error: %v", err)
	}
}
```

### 启动 RPC 服务

```shell
make build  # 构建二进制
make run    # 启动服务 (./bin/server)
```

RPC 服务启动，输出日志：

```shell
2020/12/16 01:07:06 grpc server start: :9800
```

测试 RPC 接口：

```shell
make rpc    // 执行 go run test/user.go
```

输出日志：

```shell
// 调服务端 RPC 接口 模拟注册一个用户
2020/12/16 01:16:21 register user id: 100
```

### 服务停机

按下 `ctrl + c`，服务优雅停机，输出日志：

```shell
2020/12/16 01:16:17 grpc server start: :9800
2020/12/16 01:16:21 save user, name: zhangsan, age: 20, id: 100
2020/12/16 01:16:24 signal caught: interrupt, ready to quit...
2020/12/16 01:16:24 grpc server gracefull stop
```
-----
# 工程化

- **先了解一下 [Standard Go Project Layout][1]**


## model -dao - service - server - api

1. model 面向数据库的结构体，参考贫血模型，定义相关方法
2. cache miss 在dao层处理
3. service 层与grpc / 路由 绑定
4. service 负责 dto -> do 转换的deep copy

## data - biz - service -api

1. service 是api的实现类， 实现了dto - do的转换、编排逻辑。
``` golang
    type ShopService struct{
        UnimplmentedShopService
        ouc *biz.OrderUser
    }
    // 依赖注入do层
    func NewShopService(ouc &biz.OrderUser) ShopService{
        return &ShopService{ouc:ouc}
    }

    // 关注api实现
    func(svr *ShopService) CreateOrder(ctx context.Context, r *CreateOrderRequest)  (*CreateOrderReply, error){
        // dto -> do
        o:= new(biz.Order)
        o.Item= r.Name

        // 编排逻辑
        svr.ouc.Buy(o)
        return &CreateOrderReply{Message:"ok"}, nil
    }
```
2. biz是业务逻辑层，定义领域对象do，及业务逻辑的具体实现
``` golang
    // 定义do 
    type Order struct{
        Item string
    }
    // PO 持久化的interface
    type OrderRepo interface{
        SaveOrder(*Order)
    }

    // 依赖注入
    func NewOrderUser(repo OrderRepo) *OrderUser{
        return &OrderUser{repo: repo}
    }
    type OrderUser struct{
        repo OrderRepo
    }
    // 具体实现逻辑
    func (uc *OrderUser) Buy(o *Order){
        uc.repo.SaveOrder(o)
    }
```
3. data 定义持久化对象，实现biz层定义po的interface， 存储具体逻辑，包括cache miss
``` golang
    // 告诉编译器实现了接口
    var _ biz.OrderRepo = (biz.OrderRepo)(nil)
    func NewOrderRepo() biz.OrderRepo{
        return new(orderRepo)
    }
    type orderRepo struct{}
    func (or *orderRepo) SaveOrder(o *biz.Order){

    }
```
4. 持久化对象，与持久层的数据结构形成对应关系: https://github.com/facebook/ent

## Lifecycle：

1. 所有http/grpc依赖的前置资源初始化（data, biz, service)，之后再启动监听
2. 目的：
    1. 方便测试
    2. 单次初始化，多次复用
3. 管理依赖 https://github.com/google/wire
4. 参考 https://github.com/go-kratos/kratos/blob/v2/app.go

## API规范

1. https://github.com/googleapis/googleapis https://github.com/envoyproxy/data-plane-api https://github.com/istio/api
2. 命名
    1. package <package_name>.<version>;
    2. RequestURL: /<package_name>.<version>.<service_name >/{method}
3. grpc中定义需要零值的字段使用 Wrapper类型 https://github.com/protocolbuffers/protobuf/blob/master/ src/google/protobuf/wrappers.proto
4. 错误
    1. httpcode 使用标准httpcode 而不是全使用200
    2. 当依赖的服务返回的错误时，应自行封装而不是直接往上传播
```golang
    // StatusError contains an error response from the server.
    type StatusError struct {
        // Code is the gRPC response status code and will always be populated.
        Code int `json:"code"`
        // Message is the server response message and is only populated when
        // explicitly referenced by the JSON server response.
        Message string `json:"message"`
        // Details provide more context to an error.
        Details []interface{} `json:"details"`
    }

    // ErrorInfo is a detailed error code & message from the API frontend.
    type ErrorInfo struct {
        // Reason is the typed error code. For example: "some_example".
        Reason string `json:"reason"`
        // Message is the human-readable description of the error.
        Message string `json:"message"`
    }

    // Reason returns the gRPC status for a particular error.
    // It supports wrapped errors.
    func Reason(err error) *ErrorInfo {
        if se := new(StatusError); errors.As(err, &se) {
            for _, d := range se.Details {
                if e, ok := d.(*ErrorInfo); ok {
                    return e
                }
            }
        }
        return &ErrorInfo{Reason: UnknownReason}
    }
```
5. grpc 定义部分更新使用FiledMask

配置

1. 环境变量
2. 静态配置
3. 动态配置: https://pkg.go.dev/expvar
4. 全局配置: 通过配置模版在配置中心配置
5. Functional options

```golang
    // DialOption specifies an option for dialing a Redis server.
    type DialOption struct {
    f func(*dialOptions)
    }

    // Dial connects to the Redis server at the given network and
    // address using the specified options.
    // 区分必须参数、可选参数
    func Dial(network, address string, options ...DialOption) (Conn, error) {
    do := dialOptions{
        dial: net.Dial,
    }
    for _, option := range options {
        option.f(&do)
    } // ...
    }

    // 可选参数修改配置方法
    func DialReadTimeout(d time.Duration) DialOption{
        return DialOption(func(do *dialOptions){
            do.readTimeout = d
        })
    }
```

6. 通过配置文件时：

``` golang
    // 1. 通过pb定义配置文件字段，区分可选字段、必须字段
    syntax = "proto3";
    import "google/protobuf/duration.proto";
    package config.redis.v1;
    // redis config.
    message redis {
    string network = 1;
    string address = 2;
    int32 database = 3;
    string password = 4;
    google.protobuf.Duration read_timeout = 5;
    }
    // 2. 序列化yml文件
    func ApplyYAML(s *redis.Config, yml string) error {
        js, err := yaml.YAMLToJSON([]byte(yml))
        if err != nil {
            return err
        }
        return ApplyJSON(s, string(js))
    }
    // 3. 生成option列表
    // Options apply config to options.
    func Options(c *redis.Config) []redis.Options {
        return []redis.Options{
            redis.DialDatabase(c.Database),
            redis.DialPassword(c.Password),
            redis.DialReadTimeout(c.ReadTimeout),
        }
    }

    func main() {
        // load config file from yaml.
        c := new(redis.Config)
        _ = ApplyYAML(c, loadConfig())
        r, _ := redis.Dial(c.Network, c.Address, Options(c)...)
    }

```
## 测试

1. 单元测试的基本要求：
    1. 快速
    2. 环境一致：跑完之后清理资源
    3. 任意顺序
    4. 并行
2. 利用 go 官方提供的: Subtests  + Gomock 完成整个单元测试。
    1. /api：比较适合进行集成测试，直接测试 API，使用 API 测试框架(例如: yapi)，维护大量业务测试 case。
    2. /data：docker compose 把底层基础设施真实模拟，因此可以去掉 infra 的抽象层。
    3. /biz： 依赖  repo、rpc client，利用 gomock 模拟 interface 的实现，来进行业务单元测试。
    4. /service： 依赖 biz 的实现，构建 biz 的实现类传入，进行单元测试。
3. 基于 git branch 进行 feature 开发，本地进行 unittest，之后提交 gitlab merge request 进行 CI 的单元测试，基于 feature branch 进行构建，完成功能测试，之后合并 master，进行集成测试，上线后进行回归测试。

[1]: https://github.com/go-abao/project-layout/blob/master/README_zh.md